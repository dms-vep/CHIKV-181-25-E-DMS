""" 
Snakemake pipeline for the nextstrain analysis of CHIKV.

Author: Will Hannon
Based on Caleb Carr's RABV nextstrain pipeline.
"""

#### ----------------------- Imports ----------------------- ####

import pandas as pd 
import json
from os.path import join
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

#### -------------------- Configuration -------------------- ####

configfile: "configuration/pipeline.yaml"

#### ----------------------- Targets ----------------------- ####

rule all:
    input:
        join(config['auspice_dir'], "auspice.json"),

#### ------------------------ Rules ------------------------ ####


rule make_reference:
    """
    Make a reference GenBank from a CDS.

    The reference is used to translate nucleotide mutations.
    """
    output: 
        join(config['reference_dir'], "reference.gb")
    params:
        feature=config['feature'],
        name=config['name'],
        reference=config['library']['accession'],
        gene_mapping=json.dumps(json.dumps(config['genes'])),
    conda: "nextstrain"
    log: join(config['log_dir'], "make-reference.log")
    shell:
        """
        python workflow/scripts/make-reference.py \
            --reference {params.reference} \
            --product "{params.feature}" \
            --name "{params.name}" \
            --gene_mapping {params.gene_mapping} \
            --output {output} \
            &>> {log}
        """


rule download_records:
    """
    Download all sequence records from GenBank.

    Records are fetched using the Entrez API.
    Note that this rule takes a long time to run,
    approximately 1 second per record to download.
    """
    input: 
        config['accessions']['all']
    output: 
        join(config['sequence_dir'], "records.pickle")
    params:
        include=config['accessions']['include'],
    conda: "nextstrain"
    log: join(config['log_dir'], "download-records.log")
    shell:
        """
        python workflow/scripts/download-records.py \
            --accessions {input} \
            --include {params.include} \
            --output {output} \
            &>> {log}
        """


rule parse_feature:
    """
    Parse the target sequence feature from all sequences.
    
    The features matching your target are identified by alignment.
    A single feature is returned per record, whichever aligns best.
    """
    input: 
        join(config['sequence_dir'], "records.pickle")
    output: 
        join(config['sequence_dir'], "parsed_features.csv")
    params:
        feature=config['feature'],
        reference=config['library']['accession'],
    conda: "nextstrain"
    log: join(config['log_dir'], "parse-feature.log")
    shell:
        """
        python workflow/scripts/parse-feature.py \
            --input {input} \
            --feature "{params.feature}" \
            --reference {params.reference} \
            --output {output} \
            &>> {log}
        """


rule filter_records:
    """
    Filter the records base on feature alignment.

    Given a set of parameters defined in the config,
    this rule extracts sequences that meet the criteria.
    The resulting sequences are used to build the tree.
    """
    input: 
        features=join(config['sequence_dir'], "parsed_features.csv"),
        records=join(config['sequence_dir'], "records.pickle")
    output: 
        join(config['sequence_dir'], "filtered_features.csv")
    params:
        include=config['accessions']['include'],
        outgroup=config['outgroup']['accession'],
        min_feature_length=config['filter']['min_feature_length'],
        max_feature_length=config['filter']['max_feature_length'],
        max_ambiguous_positions=config['filter']['max_ambiguous_positions'],
        remove_duplicates=config['filter']['remove_duplicates'],
        remove_partial=config['filter']['remove_partial'],
        min_alignment_score=config['filter']['min_alignment_score'],
    conda: "nextstrain"
    log: join(config['log_dir'], "filter-records.log")
    shell:
        """
        python workflow/scripts/filter-records.py \
            --features {input.features} \
            --records {input.records} \
            --include {params.include} \
            --outgroup {params.outgroup} \
            --min_feature_length {params.min_feature_length} \
            --max_feature_length {params.max_feature_length} \
            --max_ambiguous_positions {params.max_ambiguous_positions} \
            --remove_duplicates {params.remove_duplicates} \
            --remove_partial {params.remove_partial} \
            --min_alignment_score {params.min_alignment_score} \
            --output {output} \
            &>> {log}
        """


rule extract_metadata:
    """
    Extract the metadata for the filtered accessions.

    The sanitized metadata for each record is stored in
    a custom GenBank object. Some additional sanitization
    may be required.

    The geographic information is parsed using API calls
    to the REST Countries API. This will fail if you
    don't have an internet connection.
    """
    input: 
        records=join(config['sequence_dir'], "records.pickle"),
        filtered=join(config['sequence_dir'], "filtered_features.csv")
    output: 
        join(config['metadata_dir'], "metadata.tsv")
    params:
        country_mapping=json.dumps(json.dumps(config['country_mapping'])),
        host_mapping=json.dumps(json.dumps(config['host_mapping'])),
    conda: "nextstrain"
    log: join(config['log_dir'], "extract-metadata.log")
    shell:
        """
        python workflow/scripts/extract-metadata.py \
            --records {input.records} \
            --filtered {input.filtered} \
            --country_mapping {params.country_mapping} \
            --host_mapping {params.host_mapping} \
            --output {output} \
            &>> {log}
        """


rule custom_metadata_formatting:
    """
    Custom metadata formatting performed in an notebook.

    Edit this notebook for custom metadata formatting.
    This is also a good place to before custom checks.
    """
    input: 
        metadata=join(config['metadata_dir'], "metadata.tsv"),
        lineages=join("data", "ViennaRNA_CHIKV_metadata.tsv")
    output:
        metadata=join(config['metadata_dir'], "metadata_formatted.tsv")
    conda: "nextstrain"
    log: notebook=join(config['notebook_dir'],"custom-metadata-formatting.ipynb")
    notebook: 'notebooks/custom-metadata-formatting.ipynb'

 
rule extract_sequences:
    """
    Extract the nucleotide sequences from the filtered accessions.

    The name of the sequence is set to the strain name.
    Strain names MUST be unique across all records. A 
    safe way to ensure this is to use the accession appended
    to the strain name from the GenBank record.
    """
    input: 
        features=join(config['sequence_dir'], "filtered_features.csv"),
        metadata=join(config['metadata_dir'], "metadata_formatted.tsv")
    output: 
        join(config['sequence_dir'], "nucleotide.fa")
    run:
        features_df = pd.read_csv(input.features)
        metadata_df = pd.read_csv(input.metadata, sep='\t')
        records = []
        for idx, row in features_df.iterrows():
            strain = metadata_df.loc[metadata_df['accession'] == row['accession'], 'strain'].values[0]
            record = SeqRecord(
                Seq(row['sequence']),
                id=strain,
                description=""
            )
            records.append(record)
        SeqIO.write(records, output[0], "fasta")


rule extract_orfs:
    """
    Use EMBOSS to extract the open reading frames for each sequence.

    This is necessary when dealing with non-exact coordinates in the
    GenBank records. In those cases, the sequences don't always match
    the CDS translation in the GenBank record. This causes issues with
    the codon alignment and tree building steps.
    """
    input:
        join(config['sequence_dir'], "nucleotide.fa")
    params:
        min_feature_length=config["filter"]['min_feature_length']
    output:
        join(config['sequence_dir'], "orfs.fa")
    conda: "nextstrain"
    log: join(config['log_dir'], "extract-orfs.log")
    shell:
        """
        getorf \
            -sequence {input} \
            -outseq {output} \
            -find 0 \
            -minsize {params.min_feature_length} \
            -reverse No \
            -methionine No \
            -verbose \
            &> {log}
        """


rule extract_coding_regions:
    """
    Extract the protein and codon sequences from the ORFs.
    """
    input: 
        orfs=join(config['sequence_dir'], "orfs.fa"),
        sequences=join(config['sequence_dir'], "nucleotide.fa")
    output:
        protein=join(config['sequence_dir'], "protein.fa"),
        codon=join(config['sequence_dir'], "codon.fa")
    conda: "nextstrain"
    log: join(config['log_dir'], "extract-coding-regions.log")
    shell:
        """
        python workflow/scripts/extract-coding-regions.py \
            --orfs {input.orfs} \
            --sequences {input.sequences} \
            --protein {output.protein} \
            --codon {output.codon} \
            &> {log}
        """


rule align_proteins:
    """
    Align the protein sequences using MAFFT.
    """
    input: 
        join(config['sequence_dir'], "protein.fa")
    output:
        join(config['align_dir'], "protein.fa")
    conda: "nextstrain"
    log: join(config['log_dir'], "align-proteins.log")
    shell:
        """
        mafft --auto {input} > {output} 2>> {log}
        """


rule align_codons:
    """
    Create a codon alignment from the protein alignment.

    The codon alignment is created by aligning the protein
    translations and then extracting the codon sequences
    from the unaligned nucleotide sequences.
    """
    input: 
        sequences=join(config['sequence_dir'], "codon.fa"),
        alignment=join(config['align_dir'], "protein.fa")
    output:
        join(config['align_dir'], "codon.fa")
    conda: "nextstrain"
    log: join(config['log_dir'], "align-codons.log")
    shell:
        """
        python workflow/scripts/align-codons.py \
            --alignment {input.alignment} \
            --sequences {input.sequences} \
            --output {output} \
            &>> {log}
        """


rule ungap_protein_alignment:
    """
    Remove gaps from the protein alignment relative to the reference.
    """
    input: 
        join(config['align_dir'], "protein.fa")
    output:
        join(config['align_dir'], "protein_ungapped.fa")
    params: reference=config['library']['strain']
    conda: "nextstrain"
    log: join(config['log_dir'], "ungap-protein-alignment.log")
    shell:
        """
        python workflow/scripts/ungap-alignment.py \
            --alignment {input} \
            --reference {params.reference} \
            --output {output} \
            &>> {log}
        """


rule ungap_codon_alignment:
    """
    Remove gaps from the codon alignment relative to the reference.
    """
    input: 
        join(config['align_dir'], "codon.fa")
    output:
        join(config['align_dir'], "codon_ungapped.fa")
    params: reference=config['library']['strain']
    conda: "nextstrain"
    log: join(config['log_dir'], "ungap-codon-alignment.log")
    shell:
        """
        python workflow/scripts/ungap-alignment.py \
            --alignment {input} \
            --reference {params.reference} \
            --output {output} \
            &>> {log}
        """


rule build_tree:
    """
    Build a phylogenetic tree from the codon alignments.

    THe outgroup is specified in the config file using the
    strain name that appears in the fasta header for that
    sequence.
    """
    input:
        join(config['align_dir'], "codon_ungapped.fa")
    output:
        join(config['tree_dir'], "tree_raw.nwk")
    params:
        outgroup=config['outgroup']['strain'],
    conda: "nextstrain"
    log: join(config['log_dir'], "build-tree.log")
    shell:
        """
        augur tree \
            --alignment {input} \
            --tree-builder-args '\-o {params.outgroup}' \
            --output {output} \
            &> {log}
        """


rule root_and_remove_outgroup:
    """
    Root the tree and remove the outgroup.
    """
    input:
        tree=join(config['tree_dir'], "tree_raw.nwk"),
        protein=join(config['align_dir'], "protein_ungapped.fa"),
        codon=join(config['align_dir'], "codon_ungapped.fa"),
    output:
        tree=join(config['tree_dir'], "tree_no_outgroup.nwk"),
        protein=join(config['align_dir'], "protein_no_outgroup.fa"),
        codon=join(config['align_dir'], "codon_no_outgroup.fa")    
    params:
        outgroup=config['outgroup']['strain'],
    conda: "nextstrain"
    log: join(config['log_dir'], "root-and-remove-outgroup.log")
    shell:
        """
        python workflow/scripts/root-and-remove-outgroup.py \
            --tree {input.tree} \
            --protein {input.protein} \
            --codon {input.codon} \
            --outgroup {params.outgroup} \
            --output_tree {output.tree} \
            --output_protein {output.protein} \
            --output_codon {output.codon} \
            &> {log}
        """


rule refine_tree_sequences:
    """
    Refine the tree sequences using augur refine.

    At this point, branch lengths are estimated and 
    appended to each node. This step can also generate
    a time tree.
    """
    input:
        tree=join(config['tree_dir'], "tree_no_outgroup.nwk"),
        codon=join(config['align_dir'], "codon_no_outgroup.fa"),
        metadata=join(config['metadata_dir'], "metadata_formatted.tsv")
    output:
        tree=join(config['tree_dir'], "tree.nwk"),
        nodes=join(config['tree_dir'], "tree_nodes.json"),
    conda: "nextstrain"
    log: join(config['log_dir'], "refine-tree-sequences.log")
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.codon} \
            --metadata {input.metadata} \
            --output-tree {output.tree} \
            --output-node-data {output.nodes} \
            --keep-root \
            --verbosity 2 \
            &> {log}
        """


rule traits_tree_sequences:
    """
    Add the traits from the metadata to the tree.

    Additionally, this step will infer traits specified
    in the config file.
    """
    input:
        tree=join(config['tree_dir'], "tree.nwk"),
        metadata=join(config['metadata_dir'], "metadata_formatted.tsv")
    output:
        tree_traits=join(config['tree_dir'], "tree_traits.json"),
    params:
        traits=config['inferred_traits'],
    conda: "nextstrain"
    log: join(config['log_dir'], "traits-tree-sequences.log")
    shell:
        """
        augur traits \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --output-node-data {output.tree_traits} \
            --columns {params.traits} \
            --confidence \
            &> {log}
        """


rule ancestral_tree_sequences:
    """
    Reconstruct the ancestral sequences from the tree.

    These are the nucleotide sequences at each node.
    """
    input:
        tree=join(config['tree_dir'], "tree.nwk"),
        codon=join(config['align_dir'], "codon_no_outgroup.fa"),
    output:
        ancestral=join(config['tree_dir'], "tree_muts.json"),
    conda: "nextstrain"
    log: join(config['log_dir'], "ancestral-tree-sequences.log")
    shell:
        """
        augur ancestral \
            --tree {input.tree} \
            --alignment {input.codon} \
            --output-node-data {output.ancestral} \
            --inference joint \
            &> {log}
        """


rule translate_tree_sequences:
    """
    Use the GenBank reference to translate the nucleotide mutations.

    Generally, this should be the same sequence as your library.
    """
    input:
        tree=join(config['tree_dir'], "tree.nwk"),
        ancestral=join(config['tree_dir'], "tree_muts.json"),
        reference=join(config['reference_dir'], "reference.gb")
    output:
        translation=join(config['tree_dir'], "tree_aa_muts.json"),
        gene_alignments=expand(join(config['align_dir'], "{genes}.fasta"), genes=[value for key, value in config['genes'].items()])
    params:
        genes=[value for key, value in config['genes'].items()]
    conda: "nextstrain"
    log: join(config['log_dir'], "translate-tree-sequences.log")
    shell:
        """
        augur translate \
            --tree {input.tree} \
            --ancestral-sequences {input.ancestral} \
            --reference-sequence {input.reference} \
            --output-node-data {output.translation} \
            --genes {params.genes} \
            --alignment-output results/alignments/%GENE.fasta \
            &> {log}
        """


rule color_traits:
    """
    Assign color schemes to traits in the tree.

    Optionally, order traits by a column in the metadata.
    """
    input:
        schemes=config["color"]["scheme"],
        metadata=join(config['metadata_dir'], "metadata_formatted.tsv")
    output:
        join(config['tree_dir'], "colors.tsv"),
    params:
        traits=config['color']['traits'],
        ordering=json.dumps(json.dumps(config['color']['ordering'])),
    conda: "nextstrain"
    log: join(config['log_dir'], "color-traits.log")
    shell:
        """
        python workflow/scripts/color-traits.py \
            --metadata {input.metadata} \
            --schemes {input.schemes} \
            --traits {params.traits} \
            --ordering {params.ordering} \
            --output {output} \
            &> {log}
        """


rule export_tree:
    """
    Exports the tree to visualize with Auspice

    View the tree in your browser at https://auspice.us/
    """
    input:
        tree=join(config['tree_dir'], "tree.nwk"),
        metadata=join(config['metadata_dir'], "metadata_formatted.tsv"),
        nodes=join(config['tree_dir'], "tree_nodes.json"),
        traits=join(config['tree_dir'], "tree_traits.json"),
        ancestral=join(config['tree_dir'], "tree_muts.json"),
        translation=join(config['tree_dir'], "tree_aa_muts.json"),
        colors=join(config['tree_dir'], "colors.tsv"),
        config=config["auspice"]["config"],
        coordinates=config["auspice"]["coordinates"],
    params:
        title=config["auspice"]["title"],
        description=config["auspice"]["description"],
    output:
        join(config['auspice_dir'], "auspice.json"),
    conda: "nextstrain"
    log: join(config['log_dir'], "export-tree.log")
    shell:
        """
        augur export v2 \
            --tree {input.tree} \
            --title "{params.title}" \
            --description "{params.description}" \
            --metadata {input.metadata} \
            --node-data {input.nodes} {input.traits} {input.ancestral} {input.translation} \
            --include-root-sequence-inline \
            --colors {input.colors} \
            --lat-longs {input.coordinates} \
            --auspice-config {input.config} \
            --output {output} \
            &> {log}
        """
